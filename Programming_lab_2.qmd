---
title: "Programming_Lab_2"
author: "Zivanic, Lugli, Battaglio"
format: html
editor: visual
---

#Gender equality in the work place

{r}
library(readr)
library(tidyverse)
library(gapminder)
library(ggplot2)
library(dplyr)
library(knitr)
library(broom)
library(magrittr)
library(knitr)
library(plotly)

getwd()
setwd("/Users/chiarazivanic/Desktop/Programminglab2")
paygapEU <- read.csv("pay_gap_Europe.csv")

head(paygapEU)
summary(paygapEU$GDP)
paygap <- paygapEU |> filter(Country %in% c("Italy", "Switzerland", "Bulgaria")) |> select(-c(Industry, Electricity_supply, Water_supply, Retail.trade, Transportation, Accommodation, Information, Financial, Professional_scientific, Administrative, Public_administration, Human_health, Arts, Other))

paygapEU <- paygapEU |> mutate(Secondary_sector = rowMeans(select(paygapEU, Construction, Mining, Manufacturing), na.rm=TRUE))

# Esegui la regressione lineare generale 
lin_mod1 <- lm(Secondary_sector ~ GDP, data = paygapEU)
summary(lin_mod1)

# Crea il grafico utilizzando ggplot2
ggplot(paygapEU, aes(x = GDP, y = Secondary_sector, color = Country)) +
  geom_point(alpha = 0.5) +  
  geom_smooth(data = paygapEU, method = "lm", se = TRUE, aes(fill = Country), alpha = 0.2) +  
  geom_line(data = data.frame(GDP = unique(paygapEU$GDP), predictions = predict(lin_mod1, newdata = data.frame(GDP = unique(paygapEU$GDP)))), 
            aes(x = GDP, y = predictions), color = "black", size = 1) +  
  labs(title = "Regressione di Secondary_sector su GDP",
       x = "GDP",
       y = "Secondary Sector") +
  theme_minimal()

summary(lin_mod1)

# Unfortunately, the coefficient on GDP is very small (0.00002511), and even the p value is very high (0.394), so that we can not know for sure the dimension of the causality effect. We try adding some more regressors.

lin_mod2 <- lm(Secondary_sector ~ GDP + Year + Urban_population, data=paygap)
summary(lin_mod2)

# Again, the coefficient on GDP is quite similar as before, still very small and negligible. As concerns the other two regressors, for a 1% increase in urban population the pay gap decreases by 0.3398, and as years go by pay gap decreases by 0.357 every year. It is to note, however, that these values are not statistically significant, as the p value is again very large (only for the coefficient on the year variable, we can confide in its significance but at a 10% significance level).


# Milena



### upload the new dataset and section it

```{r}
management <- read.csv("Employment in senior and middle management, female (%).csv")
view(management)
```

### new variable european countries

```{r}
all_countries <- unique(management$Country.Name)
#print useful to get the complete list of european countries

# List of European countries
european_countries <- c(
    "Albania", "Austria", "Belarus", "Belgium", "Bosnia and Herzegovina", "Bulgaria", 
    "Croatia", "Cyprus", "Czechia", "Denmark", "Estonia", "Finland", "France", 
    "Georgia", "Germany", "Greece", "Hungary", "Iceland", "Ireland", "Italy", 
    "Latvia", "Lithuania", "Luxembourg", "Malta", "Moldova", "Monaco", 
    "Montenegro", "Netherlands", "North Macedonia", "Norway", "Poland", "Portugal", 
    "Romania", "Russia", "San Marino", "Serbia", "Slovakia", "Slovenia", "Spain", 
    "Sweden", "Switzerland", "Turkey", "Ukraine", "United Kingdom", "Vatican City"
)

# Create a new variable Country.NameEU containing only European countries
management <- management %>%
  mutate(Country.NameEU = ifelse(Country.Name %in% european_countries, Country.Name, NA))

# View the 'management' dataset to check the updated variable
view(management)
```

### distribution of the Female share of employment in senior and middle management (%) in European countries

```{r}
# Filter the dataset for only European countries
e_management <- subset(management, Country.Name %in% european_countries)

# Filter the dataset for the most recent year's data for each country
recent_data <- e_management %>%
  group_by(Country.NameEU) %>%
  filter(Year == max(Year))  # Filter for rows with the maximum Year value for each country

# Create the choropleth map with the filtered recent_data
map <- plot_geo(recent_data, locations = ~Country.NameEU, locationmode = "country names") %>%
  add_trace(
    z = ~Value,
    text = ~paste("Country: ", Country.NameEU, "<br>Percentage of Females: ", Value, "%"),
    colorscale = "Viridis",
    colorbar = list(title = "Percentage of Females in Managerial Positions")
  ) %>%
  layout(
    title = "Most Recent Year: Percentage of Females in Managerial Positions by European Countries",
    geo = list(scope = "europe")
  )

# Show the map
map
```

```{r}
# Sort the data by 'Value' in descending order
sorted_data <- e_management[order(-e_management$Value), ]

# Extract the highest three values
highest_three <- head(sorted_data, 3)

# Extract the lowest three values
lowest_three <- tail(sorted_data, 3)

# Print the highest and lowest three values
cat("Highest Three:\n")
print(highest_three[, c("Country.NameEU", "Value")])

cat("\nLowest Three:\n")
print(lowest_three[, c("Country.NameEU", "Value")])

```

```{r}
# ho tolto List of European countries

# Create 'Country.NameEU' in 'paygapEU' dataset
paygapEU$Country.NameEU <- ifelse(paygapEU$Country %in% european_countries, paygapEU$Country, NA)

# Create 'Country.NameEU' in 'paygapEU' dataset
paygapEU$Country.NameEU <- ifelse(paygapEU$Country %in% european_countries, paygapEU$Country, NA)

```

```{r}
## Check unique values in 'Country.NameEU' column in 'management'
unique_countries_management <- unique(management$Country.NameEU)
print(unique_countries_management)

# Check unique values in 'Country.NameEU' column in 'paygapEU'
unique_countries_paygapEU <- unique(paygapEU$Country.NameEU)
print(unique_countries_paygapEU)

# Merge 'paygapEU' with 'paygap' based on the 'Country' column
paygapEU <- merge(paygapEU, paygap[, c("Country", "Secondary_sector")], by = "Country", all.x = TRUE)

# View the updated 'paygapEU' dataset
print(head(paygapEU))

# Merge the datasets on a common column ('Country.NameEU' assumed)
merged_data <- merge(management, paygapEU, by = "Country.NameEU")
# Check column names in the merged dataset
print(colnames(merged_data))
# Assuming 'Secondary_sector.x' is the relevant column
model <- lm(Value ~ Secondary_sector, data = merged_data)

# Summary of the regression model
summary(model)

# Perform linear regression with 'Value' and 'Secondary_sector'
model <- lm(Value ~ Secondary_sector, data = merged_data)

# Summary of the regression model
summary(model)

```

### plot a scatter plot of the previous regression

```{r}
# Scatter plot with regression line using Plotly
plot <- ggplot(merged_data, aes(x = Secondary_sector, y = Value)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) +
  labs(x = "Secondary Sector", y = "Percentage of Females in Managerial Positions") +
  ggtitle("Regression of Percentage of Females in Managerial Positions vs Secondary Sector")

# Convert ggplot to Plotly
plotly_plot <- ggplotly(plot)

# Display the Plotly plot
plotly_plot

```

This model suggests a negative relationship between 'Secondary_sector' and 'Value' (percentage of females in managerial positions), implying that as the 'Secondary_sector' variable increases, the 'Value' decreases, holding other factors constant.

While statistically significant, the R-squared value is relatively low, indicating that 'Secondary_sector' might not be the only influential factor determining the percentage of females in managerial positions. Other variables or factors might contribute to this as well.
