---
title: "Programming_Lab_2"
author: "Zivanic, Lugli, Battaglio"
format: html
editor: visual
---

#Gender equality in the work place

{r}
library(readr)
library(tidyverse)
library(gapminder)
library(ggplot2)
library(dplyr)
library(knitr)
library(broom)
library(magrittr)
library(knitr)
library(plotly)

getwd()
setwd("/Users/chiarazivanic/Desktop/Programminglab2")
paygapEU <- read.csv("pay_gap_Europe.csv")

head(paygapEU)
summary(paygapEU$GDP)
paygap <- paygapEU |> filter(Country %in% c("Italy", "Switzerland", "Bulgaria")) |> select(-c(Industry, Electricity_supply, Water_supply, Retail.trade, Transportation, Accommodation, Information, Financial, Professional_scientific, Administrative, Public_administration, Human_health, Arts, Other))

paygapEU <- paygapEU |> mutate(Secondary_sector = rowMeans(select(paygapEU, Construction, Mining, Manufacturing), na.rm=TRUE))

# Esegui la regressione lineare generale 
lin_mod1 <- lm(Secondary_sector ~ GDP, data = paygapEU)
summary(lin_mod1)

# Crea il grafico utilizzando ggplot2
ggplot(paygapEU, aes(x = GDP, y = Secondary_sector, color = Country)) +
  geom_point(alpha = 0.5) +  
  geom_smooth(data = paygapEU, method = "lm", se = TRUE, aes(fill = Country), alpha = 0.2) +  
  geom_line(data = data.frame(GDP = unique(paygapEU$GDP), predictions = predict(lin_mod1, newdata = data.frame(GDP = unique(paygapEU$GDP)))), 
            aes(x = GDP, y = predictions), color = "black", size = 1) +  
  labs(title = "Regressione di Secondary_sector su GDP",
       x = "GDP",
       y = "Secondary Sector") +
  theme_minimal()

summary(lin_mod1)

# Unfortunately, the coefficient on GDP is very small (0.00002511), and even the p value is very high (0.394), so that we can not know for sure the dimension of the causality effect. We try adding some more regressors.

lin_mod2 <- lm(Secondary_sector ~ GDP + Year + Urban_population, data=paygap)
summary(lin_mod2)

# Again, the coefficient on GDP is quite similar as before, still very small and negligible. As concerns the other two regressors, for a 1% increase in urban population the pay gap decreases by 0.3398, and as years go by pay gap decreases by 0.357 every year. It is to note, however, that these values are not statistically significant, as the p value is again very large (only for the coefficient on the year variable, we can confide in its significance but at a 10% significance level).


# Milena

### upload the new dataset and section it

```{r}
management <- read.csv("Employment in senior and middle management, female (%).csv")
view(management)
```

#### new variable european countries

```{r}
all_countries <- unique(management$Country.Name)
#print useful to get the complete list of european counntries

# List of European countries
european_countries <- c(
    "Albania", "Austria", "Belarus", "Belgium", "Bosnia and Herzegovina", "Bulgaria", 
    "Croatia", "Cyprus", "Czechia", "Denmark", "Estonia", "Finland", "France", 
    "Georgia", "Germany", "Greece", "Hungary", "Iceland", "Ireland", "Italy", 
    "Latvia", "Lithuania", "Luxembourg", "Malta", "Moldova", "Monaco", 
    "Montenegro", "Netherlands", "North Macedonia", "Norway", "Poland", "Portugal", 
    "Romania", "Russia", "San Marino", "Serbia", "Slovakia", "Slovenia", "Spain", 
    "Sweden", "Switzerland", "Turkey", "Ukraine", "United Kingdom", "Vatican City"
)

# Create a new variable Country.NameEU containing only European countries
management <- management %>%
  mutate(Country.NameEU = ifelse(Country.Name %in% european_countries, Country.Name, NA))

# View the 'management' dataset to check the updated variable
view(management)


```

### distribution of the Female share of employment in senior and middle management (%) in European countries

```{r}
# Filter the dataset for only European countries
e_management <- subset(management, Country.Name %in% european_countries)

# Filter the dataset for the most recent year's data for each country
recent_data <- e_management %>%
  group_by(Country.NameEU) %>%
  filter(Year == max(Year))  # Filter for rows with the maximum Year value for each country

# Create the choropleth map with the filtered recent_data
map <- plot_geo(recent_data, locations = ~Country.NameEU, locationmode = "country names") %>%
  add_trace(
    z = ~Value,
    text = ~paste("Country: ", Country.NameEU, "<br>Percentage of Females: ", Value, "%"),
    colorscale = "Viridis",
    colorbar = list(title = "Percentage of Females in Managerial Positions")
  ) %>%
  layout(
    title = "Most Recent Year: Percentage of Females in Managerial Positions by European Countries",
    geo = list(scope = "europe")
  )

# Show the map
map
```

```{r}
# Filter for the most recent date for each country
most_recent_data <- e_management %>%
  group_by(Country.NameEU) %>%
  filter(Year == max(Year))  # Filter for rows with the maximum Year value for each country

# Sort the most recent data by 'Value' in descending order
sorted_most_recent <- most_recent_data %>% arrange(desc(Value))

# Extract the highest three values
highest_three <- head(sorted_most_recent, 3)

# Extract the lowest three values
lowest_three <- tail(sorted_most_recent, 3)

# Print the highest and lowest three values
cat("Highest Three:\n")
print(highest_three[, c("Country.NameEU", "Value")])

cat("\nLowest Three:\n")
print(lowest_three[, c("Country.NameEU", "Value")])

```

Upload the dataset for managerial positions
```{r}
# ho tolto List of European countries

# Create 'Country.NameEU' in 'paygapEU' dataset
paygapEU$Country.NameEU <- ifelse(paygapEU$Country %in% european_countries, paygapEU$Country, NA)

```

```{r}
# Check unique values in 'Country.NameEU' column in 'management'
unique_countries_management <- unique(management$Country.NameEU)
#print(unique_countries_management)

# Check unique values in 'Country.NameEU' column in 'paygapEU'
unique_countries_paygapEU <- unique(paygapEU$Country.NameEU)
print(unique_countries_paygapEU)

# Merge 'paygapEU' with 'paygap' based on the 'Country' column
paygapEU <- merge(paygapEU, paygap[, c("Country", "Secondary_sector")], by = "Country", all.x = TRUE)


# Merge the datasets on a common column
merged_data <- merge(management, paygapEU, by = "Country.NameEU")
view(merged_data)

# Perform linear regression with 'Value' and 'Secondary_sector'
model <- lm(Secondary_sector ~ Value, data = merged_data)

# Summary of the regression model
summary(model)

```

### plot a scatter plot of the previous regression

```{r}

# Create a scatter plot with regression line
ggplot(merged_data, aes(x = Value, y = Secondary_sector)) +
  geom_point() +  # Scatter plot
  geom_smooth(method = "lm", se = FALSE, color = "blue") +  # Regression line
  labs(title = "Linear Regression: Value vs Secondary_sector",
       x = "Percentage of female managers", y = "Secondary_sector")  # Labels for the plot

```

This model suggests a negative relationship between 'Secondary_sector' and 'Value' (percentage of females in managerial positions), implying that as the percentage of females in managerial position increases the gender pay gap decreases.

While statistically significant, the R-squared value is relatively low, indicating that 'Value' might not be the only influential factor determining the percentage of females in managerial positions. Other variables or factors might contribute to this as well.

### upload dataset about unpaid domestic and care work
```{r}
domestic <- read.csv("Proportion of time spent on unpaid domestic and care work (% of 24 hour day).csv")

# Rename 'Value' column to 'Value2' in the 'domestic' dataset
domestic <- domestic %>%
  rename(Value2 = Value)

# Check the updated column names
print(colnames(domestic))
view(domestic)

```

```{r}

domestic <- domestic %>%
  mutate(Country.NameEU = ifelse(Country.Name %in% european_countries, Country.Name, NA))

view(domestic)
```

### graph to show the distribution
```{r}
# Filter the dataset for only European countries
e_domestic <- subset(domestic, Country.Name %in% european_countries)
view(e_domestic)

# Create a choropleth map
map <- plot_geo(e_domestic, locations = ~Country.NameEU, locationmode = "country names") %>%
  add_trace(
    z = ~Value2,
    text = ~paste("Country: ", Country.NameEU, "<br>Proportion of time spent on unpaid domestic and care work: ", Value2, "%"),
    colorscale = "Viridis",
    colorbar = list(title = "Proportion of time spent on unpaid domestic and care work")
  ) %>%
  layout(
    title = "Proportion of time spent on unpaid domestic and care work",
    geo = list(scope = "europe")
  )

# Show the map
map
```
why do I have an error in the code below?

```{r}
# Filter for the most recent date for each country
most_recent_data_domestic <- e_domestic %>%
  group_by(Country.NameEU) %>%
  filter(Year == max(Year))  # Filter for rows with the maximum Year value for each country

# Sort the most recent data by 'Value2' in descending order
sorted_most_recent_domestic <- most_recent_data_domestic %>% arrange(desc(Value2))

# Extract the highest three values
highest_three_domestic <- head(sorted_most_recent_domestic, 3)

# Extract the lowest three values
lowest_three_domestic <- tail(sorted_most_recent_domestic, 3)

# Print the highest and lowest three values
cat("Highest Three:\n")
print(highest_three_domestic[, c("Country.NameEU", "Value2")])

cat("\nLowest Three:\n")
print(lowest_three_domestic[, c("Country.NameEU", "Value2")])

```

```{r}
# Assuming 'Country.NameEU' is the common column

# Merge datasets on 'Country.NameEU'
merged_dataset <- merge(merged_data, e_domestic, by = "Country.NameEU", all = TRUE)

# Perform linear regression
model <- lm(Value2 ~ Secondary_sector, data = merged_dataset)

# Summary of the regression model
summary(model)

```


